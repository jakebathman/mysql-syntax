<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>fileTypes</key>
    <array>
      <string>sql</string>
      <string>ddl</string>
      <string>dml</string>
    </array>
    <key>foldingStartMarker</key>
    <string>\s*\(\s*$</string>
    <key>foldingStopMarker</key>
    <string>^\s*\)</string>
    <key>keyEquivalent</key>
    <string>^~S</string>
    <key>name</key>
    <string>MySQL</string>
    <key>patterns</key>
    <array>
      <dict>
        <key>include</key>
        <string>#comments</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.create.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>keyword.other.sql</string>
          </dict>
          <key>5</key>
          <dict>
            <key>name</key>
            <string>entity.name.function.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(create(\s+temporary)?)\s+(aggregate|conversion|database|domain|function|procedure|group|(unique\s+)?index|language|operator class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)(['"`]?)(\w+)\5</string>
        <key>name</key>
        <string>meta.create.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.create.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>keyword.other.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(drop(\s+temporary)?)\s+(aggregate|conversion|database|domain|function|procedure|group|index|language|operator class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view))</string>
        <key>name</key>
        <string>meta.drop.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.create.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>keyword.other.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(truncate(\s+table)?))</string>
        <key>name</key>
        <string>meta.truncate.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.create.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>keyword.other.table.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>entity.name.function.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>keyword.other.cascade.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:\s*(drop)\s+(table)\s+(\w+)(\s+cascade)?\b)</string>
        <key>name</key>
        <string>meta.drop.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.create.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>keyword.other.table.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(alter)\s+(aggregate|conversion|database|domain|function|procedure|group|index|language|operator class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)</string>
        <key>name</key>
        <string>meta.alter.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>10</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>11</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>12</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>13</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>14</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>15</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>5</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>6</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
          <key>7</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>8</key>
          <dict>
            <key>name</key>
            <string>constant.numeric.sql</string>
          </dict>
          <key>9</key>
          <dict>
            <key>name</key>
            <string>storage.type.sql</string>
          </dict>
        </dict>
        <key>match</key>
         <string>(?xi)
         
        # normal stuff, capture 1
         \b(bigint|bigserial|bit|boolean|box|bytea|cidr|circle|date|double\sprecision|inet|int|integer|line|lseg|macaddr|money|oid|path|point|polygon|real|serial|smallint|sysdate|text)\b

        # numeric suffix, capture 2 + 3i
        |\b(bit\svarying|character\s(?:varying)?|tinyint|var\schar|float|interval)\((\d+)\)

        # optional numeric suffix, capture 4 + 5i
        |\b(char|number|varchar\d?)\b(?:\((\d+)\))?

        # special case, capture 6 + 7i + 8i
        |\b(numeric)\b(?:\((\d+),(\d+)\))?

        # special case, captures 9, 10i, 11
        |\b(times)(?:\((\d+)\))(\swithoutstimeszone\b)?

        # special case, captures 12, 13, 14i, 15
        |\b(timestamp)(?:(s)\((\d+)\)(\swithoutstimeszone\b)?)?

      </string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b((?:primary|foreign)\s+key|references|on\sdelete(\s+cascade)?|check|constraint)\b)</string>
        <key>name</key>
        <string>storage.modifier.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\b\d+\b</string>
        <key>name</key>
        <string>constant.numeric.sql</string>
      </dict>
      <!-- SELECT ... INTO -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\s*(select)\s+(.*)\s+(into)\s+((?:\w+)(?:\,\s+)?)+)</string>
        <key>name</key>
        <string>meta.create.sql</string>
      </dict>
      <!-- PREPARE ... FROM -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\b((?:deallocate\s+)?prepare)\s+(.+?)\b)</string>
        <key>name</key>
        <string>meta.prepare.sql</string>
      </dict>
      <!-- EXECUTE ... USING -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>variable.other.member</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:^\b(execute)\s+(.+?)\b(?:\s+(using)?)?)</string>
        <key>name</key>
        <string>meta.prepare.sql</string>
      </dict>
      <!-- FROM table AS alias -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.other.DML.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>constant.other.table-name.sql</string>
          </dict>
          <key>4</key>
          <dict>
            <key>name</key>
            <string>keyword.other.alias.sql</string>
          </dict>
          <key>5</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i)\b(FROM)\s+(?:(\w+)\.)?(\w+)\b(?:\s+(AS))?(?:\s+(?!where)(\w+))?</string>
        <key>name</key>
        <string>meta.select.sql</string>
      </dict>
      <!-- SELECT ... AS alias -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>constant.other.table-name.sql</string>
          </dict>
          <key>3</key>
          <dict>
            <key>name</key>
            <string>keyword.other.alias.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i)(\w+\.)?(\S+?)\s+(AS)\s+([\w'"`]+)</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(select(\s+distinct)?|insert\s+(ignore\s+)?into|update|delete|from|set|where|group\sby|or|like|and|union(\s+all)?|having|order\sby|limit|(inner|cross)\s+join|straight_join|(left|right)(\s+outer)?\s+join|natural(\s+(left|right)(\s+outer)?)?\s+join)\b)</string>
        <key>name</key>
        <string>keyword.other.DML.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(on|((is\s+)?not\s+)?null)\b)</string>
        <key>name</key>
        <string>keyword.other.DDL.create.II.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\bvalues\b)</string>
        <key>name</key>
        <string>keyword.other.DML.II.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(begin(\s+work)?|start\s+transaction|commit(\s+work)?|rollback(\s+work)?)\b)</string>
        <key>name</key>
        <string>keyword.other.LUW.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\b(grant(\swith\sgrant\soption)?|revoke)\b)</string>
        <key>name</key>
        <string>keyword.other.authorization.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:\bin\b)</string>
        <key>name</key>
        <string>keyword.other.data-integrity.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:^\s*(comment\s+on\s+(table|column|aggregate|constraint|database|domain|function|procedure|index|operator|rule|schema|sequence|trigger|type|view))\s+.*?\s+(is)\s+)</string>
        <key>name</key>
        <string>keyword.other.object-comments.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i:^\s*(add\s+(column|index|key|constraint|unique|fulltext|spatial)))</string>
        <key>name</key>
        <string>keyword.other.alter-add.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i)\b(DESC|ASC)\b</string>
        <key>name</key>
        <string>keyword.other.order.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\*</string>
        <key>name</key>
        <string>keyword.operator.star.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>[!&lt;&gt;]?=|&lt;&gt;|&lt;|&gt;|NOT IN|\bIN\b|BETWEEN|!=|<=>|<=|=>|<|></string>
        <key>name</key>
        <string>keyword.operator.comparison.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>-|\+|/</string>
        <key>name</key>
        <string>keyword.operator.math.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>\|\|</string>
        <key>name</key>
        <string>keyword.operator.concatenator.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>All functions and operators in MySQL 5.7</string>
        <key>match</key>
        <string>(?i)\b(abs|acos|adddate|addtime|aes_decrypt|aes_encrypt|any_value|area|asbinary|ascii|asin|astext|asymmetric_decrypt|asymmetric_derive|asymmetric_encrypt|asymmetric_sign|asymmetric_verify|atan|atan2|avg|benchmark|bin|bit_and|bit_count|bit_length|bit_or|bit_xor|buffer|cast|ceil|ceiling|centroid|char|char_length|character_length|charset|coalesce|coercibility|collation|compress|concat|concat_ws|connection_id|contains|conv|convert|convert_tz|convexhull|cos|cot|count|crc32|create_asymmetric_priv_key|create_asymmetric_pub_key|create_dh_parameters|create_digest|crosses|curdate|current_date|current_time|current_timestamp|current_user|curtime|database|date|date_add|date_format|date_sub|datediff|day|dayname|dayofmonth|dayofweek|dayofyear|decode|default|degrees|des_decrypt|des_encrypt|dimension|disjoint|distance|elt|encode|encrypt|endpoint|envelope|equals|exp|export_set|exteriorring|extract|extractvalue|field|find_in_set|floor|format|found_rows|from_base64|from_days|from_unixtime|geomcollfromtext|geomcollfromwkb|geometrycollection|geometryn|geometrytype|geomfromtext|geomfromwkb|get_format|get_lock|glength|greatest|group_concat|gtid_subset|gtid_subtract|hex|hour|ifnull|in|inet_aton|inet_ntoa|inet6_aton|inet6_ntoa|insert|instr|interiorringn|intersects|interval|is_free_lock|is_ipv4|is_ipv4_compat|is_ipv4_mapped|is_ipv6|is_used_lock|isclosed|isempty|isnull|issimple|json_append|json_array|json_array_append|json_array_insert|json_contains|json_contains_path|json_depth|json_extract|json_insert|json_keys|json_length|json_merge|json_merge_preserve|json_object|json_quote|json_remove|json_replace|json_search|json_set|json_type|json_unquote|json_valid|last_insert_id|lcase|least|left|length|linefromtext|linefromwkb|linestring|ln|load_file|localtime|locate|log|log10|log2|lower|lpad|ltrim|make_set|makedate|maketime|master_pos_wait|max|mbrcontains|mbrcoveredby|mbrcovers|mbrdisjoint|mbrequal|mbrequals|mbrintersects|mbroverlaps|mbrtouches|mbrwithin|md5|microsecond|mid|min|minute|mlinefromtext|mlinefromwkb|mod|month|monthname|mpointfromtext|mpointfromwkb|mpolyfromtext|mpolyfromwkb|multilinestring|multipoint|multipolygon|name_const|now|nullif|numgeometries|numinteriorrings|numpoints|oct|octet_length|old_password|ord|overlaps|password|period_add|period_diff|pi|point|pointfromtext|pointfromwkb|pointn|polyfromtext|polyfromwkb|polygon|position|pow|power|quarter|quote|radians|rand|random_bytes|release_all_locks|release_lock|repeat|replace|reverse|right|round|row_count|rpad|rtrim|schema|sec_to_time|second|session_user|sha1|sha2|sign|sin|sleep|soundex|space|sqrt|srid|st_area|st_asbinary|st_asgeojson|st_astext|st_buffer|st_buffer_strategy|st_centroid|st_contains|st_convexhull|st_crosses|st_difference|st_dimension|st_disjoint|st_distance|st_distance_sphere|st_endpoint|st_envelope|st_equals|st_exteriorring|st_geohash|st_geomcollfromtext|st_geomcollfromwkb|st_geometryn|st_geometrytype|st_geomfromgeojson|st_geomfromtext|st_geomfromwkb|st_interiorringn|st_intersection|st_intersects|st_isclosed|st_isempty|st_issimple|st_isvalid|st_latfromgeohash|st_length|st_linefromtext|st_linefromwkb|st_longfromgeohash|st_makeenvelope|st_mlinefromtext|st_mlinefromwkb|st_mpointfromtext|st_mpointfromwkb|st_mpolyfromtext|st_mpolyfromwkb|st_numgeometries|st_numinteriorring|st_numpoints|st_overlaps|st_pointfromgeohash|st_pointfromtext|st_pointfromwkb|st_pointn|st_polyfromtext|st_polyfromwkb|st_simplify|st_srid|st_startpoint|st_symdifference|st_touches|st_union|st_validate|st_within|st_x|st_y|startpoint|std|stddev|stddev_pop|stddev_samp|str_to_date|strcmp|subdate|substr|substring|substring_index|subtime|sum|sysdate|system_user|tan|time|time_format|time_to_sec|timediff|timestamp|timestampadd|timestampdiff|to_base64|to_days|to_seconds|touches|trim|truncate|ucase|uncompress|uncompressed_length|unhex|unix_timestamp|updatexml|upper|user|utc_date|utc_time|utc_timestamp|uuid|uuid_short|validate_password_strength|values|var_pop|var_samp|variance|version|wait_for_executed_gtid_set|wait_until_sql_thread_after_gtids|week|weekday|weekofyear|weight_string|within|x|y|year|yearweek|-|\*|xor|=|\:=|between|and|binary|&|~|\||\^|case|div|<=>|>|>=|is|is not|is not null|is null|->|->>|last_day|<<|<|<=|like|localtimestamp|match|%|mod|not|!|!=|<>|not in|not like|not regexp|\|\||or|\+|regexp|>>|rlike|sounds like)\b</string>
        <key>name</key>
        <string>support.function.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>List of SQL99 built-in functions from http://www.oreilly.com/catalog/sqlnut/chapter/ch04.html</string>
        <key>match</key>
        <string>(?i)\b(CURRENT_(DATE|TIME(STAMP)?|USER)|(SESSION|SYSTEM)_USER)\b</string>
        <key>name</key>
        <string>support.function.scalar.sql</string>
      </dict>
      <dict>
        <key>comment</key>
        <string>List of SQL99 built-in functions from http://www.oreilly.com/catalog/sqlnut/chapter/ch04.html</string>
        <key>match</key>
        <string>(?i)\b(AVG|COUNT|MIN|MAX|SUM)(?=\s*\()</string>
        <key>name</key>
        <string>support.function.aggregate.sql</string>
      </dict>
      <dict>
        <key>match</key>
        <string>(?i)\b(DELIMITER|CONCATENATE|CONVERT|LOWER|SUBSTRING|TRANSLATE|TRIM|UPPER)\b</string>
        <key>name</key>
        <string>support.function.string.sql</string>
      </dict>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>constant.other.database-name.sql</string>
          </dict>
          <key>2</key>
          <dict>
            <key>name</key>
            <string>constant.other.table-name.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>\b(\w+?)\.(\w+)\b</string>
        <!-- <string>(\w+?)\.(\w+)</string> -->
      </dict>
      <!-- variables -->
      <dict>
        <key>match</key>
        <string>(?i:(@[^\s]+))</string>
        <key>name</key>
        <string>variable.other.sql</string>
      </dict>
      <!-- unsigned, autoincrement, cursor -->
      <dict>
        <key>match</key>
        <string>(?i:\b(unsigned|auto_increment|cursor)\b)</string>
        <key>name</key>
        <string>storage.type.sql</string>
      </dict>
      <!-- CALL, END -->
      <dict>
        <key>match</key>
        <string>(?i:\b(call|end(?! if)|for each row|declare)\b)</string>
        <key>name</key>
        <string>keyword.other.LUW.sql</string>
      </dict>
      <!-- IF THEN ELSE IF ELSE END IF; -->
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>keyword.control.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(?i:\b(if|then|elseif|else|end if)\b)</string>
      </dict>
      <dict>
        <key>include</key>
        <string>#strings</string>
      </dict>
      <dict>
        <key>include</key>
        <string>#regexps</string>
      </dict>
    </array>
    <key>repository</key>
    <dict>
      <key>comments</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.comment.sql</string>
              </dict>
            </dict>
            <key>match</key>
            <string>(--).*$\n?</string>
            <key>name</key>
            <string>comment.line.double-dash.sql</string>
          </dict>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.comment.sql</string>
              </dict>
            </dict>
            <key>match</key>
            <string>(#).*$\n?</string>
            <key>name</key>
            <string>comment.line.number-sign.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>/\*</string>
            <key>captures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.comment.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>\*/</string>
            <key>name</key>
            <string>comment</string>
          </dict>
        </array>
      </dict>
      <key>regexps</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>begin</key>
            <string>/(?=\S.*/)</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>/</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.regexp.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
              <dict>
                <key>match</key>
                <string>\\/</string>
                <key>name</key>
                <string>constant.character.escape.slash.sql</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>begin</key>
            <string>%r\{</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>We should probably handle nested bracket pairs!?! -- Allan</string>
            <key>end</key>
            <string>\}</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.regexp.modr.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
        </array>
      </dict>
      <key>string_escape</key>
      <dict>
        <key>match</key>
        <string>\\.</string>
        <key>name</key>
        <string>constant.character.escape.sql</string>
      </dict>
      <key>string_interpolation</key>
      <dict>
        <key>captures</key>
        <dict>
          <key>1</key>
          <dict>
            <key>name</key>
            <string>punctuation.definition.string.end.sql</string>
          </dict>
        </dict>
        <key>match</key>
        <string>(#\{)([^\}]*)(\})</string>
        <key>name</key>
        <string>string.interpolated.sql</string>
      </dict>
      <key>strings</key>
      <dict>
        <key>patterns</key>
        <array>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(')[^'\\]*(')</string>
            <key>name</key>
            <string>string.quoted.single.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>'</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>'</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.single.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_escape</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(`)[^`\\]*(`)</string>
            <key>name</key>
            <string>string.quoted.other.backtick.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>`</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>`</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.other.backtick.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_escape</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>captures</key>
            <dict>
              <key>1</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
              <key>3</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>comment</key>
            <string>this is faster than the next begin/end rule since sub-pattern will match till end-of-line and SQL files tend to have very long lines.</string>
            <key>match</key>
            <string>(")(?:[^"#]|\"|\')*(")</string>
            <key>name</key>
            <string>string.quoted.double.sql</string>
          </dict>
          <dict>
            <key>begin</key>
            <string>"</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>"</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.quoted.double.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
          <dict>
            <key>begin</key>
            <string>%\{</string>
            <key>beginCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.begin.sql</string>
              </dict>
            </dict>
            <key>end</key>
            <string>\}</string>
            <key>endCaptures</key>
            <dict>
              <key>0</key>
              <dict>
                <key>name</key>
                <string>punctuation.definition.string.end.sql</string>
              </dict>
            </dict>
            <key>name</key>
            <string>string.other.quoted.brackets.sql</string>
            <key>patterns</key>
            <array>
              <dict>
                <key>include</key>
                <string>#string_interpolation</string>
              </dict>
            </array>
          </dict>
        </array>
      </dict>
    </dict>
    <key>scopeName</key>
    <string>source.sql</string>
    <key>uuid</key>
    <string>A41BE23A-7EF9-11E5-857F-40167E632F0F</string>
  </dict>
</plist>